import test from 'tape'
import { EntryStream } from 'level-read-stream'
import { SearchIndex } from 'search-index'
import { packageVersion } from '../../src/version.js'

const sandbox = 'test/sandbox/'
const testIndex = sandbox + 'stopword-test'

const data = [
  'this is a giant banana',
  'this is a giant pineapple',
  'this is a small pineapple'
]

const autoGeneratedIds = []
const global = {}

test('create a search index', async t => {
  t.plan(1)
  try {
    global[testIndex] = await new SearchIndex({
      name: testIndex,
      stopwords: ['this', 'is', 'a', 'small']
    })
    t.ok(global[testIndex])
  } catch (e) {
    t.error(e)
  }
})

test('can add data to case sensitive index', t => {
  t.plan(9)
  global[testIndex].PUT(data).then(response =>
    response.forEach(item => {
      t.equals(item.operation, 'PUT')
      t.equals(item.status, 'CREATED')
      t.match(item._id, /\d{13}-\d/gm, 'id has correct format')
      autoGeneratedIds.push(item._id)
    })
  )
})

test('verify index structure', t => {
  const expectedIndexStructure = [
    {
      key: ['CREATED_WITH'],
      value: 'search-index@' + packageVersion
    },
    {
      key: ['DOC', autoGeneratedIds[0]],
      value: {
        body: [
          ['banana', '1.00'],
          ['giant', '1.00']
        ],
        _id: autoGeneratedIds[0]
      }
    },
    {
      key: ['DOC', autoGeneratedIds[1]],
      value: {
        body: [
          ['giant', '1.00'],
          ['pineapple', '1.00']
        ],
        _id: autoGeneratedIds[1]
      }
    },
    {
      key: ['DOC', autoGeneratedIds[2]],
      value: { body: [['pineapple', '1.00']], _id: autoGeneratedIds[2] }
    },
    { key: ['DOCUMENT_COUNT'], value: 3 },
    {
      key: ['DOC_RAW', autoGeneratedIds[0]],
      value: 'this is a giant banana'
    },
    {
      key: ['DOC_RAW', autoGeneratedIds[1]],
      value: 'this is a giant pineapple'
    },
    {
      key: ['DOC_RAW', autoGeneratedIds[2]],
      value: 'this is a small pineapple'
    },
    { key: ['FIELD', 'body'], value: 'body' },
    {
      key: ['IDX', 'body', ['banana', '1.00']],
      value: [autoGeneratedIds[0]]
    },
    {
      key: ['IDX', 'body', ['giant', '1.00']],
      value: [autoGeneratedIds[0], autoGeneratedIds[1]]
    },
    {
      key: ['IDX', 'body', ['pineapple', '1.00']],
      value: [autoGeneratedIds[1], autoGeneratedIds[2]]
    }
  ]
  t.plan(expectedIndexStructure.length)
  new EntryStream(global[testIndex].INDEX.STORE, {
    lt: ['~']
  }).on('data', d => {
    t.deepEquals(d, expectedIndexStructure.shift())
  })
})

// TODO: these tests need to be fixed! Stopwords dont work!

test('search with stopwords', t => {
  t.plan(1)
  global[testIndex]
    .QUERY({
      AND: 'this is a small banana'.split(' ')
    })
    .then(res => {
      t.deepEqual(res, {
        QUERY: { AND: ['this', 'is', 'a', 'small', 'banana'] },
        OPTIONS: {},
        RESULT: [
          {
            _id: autoGeneratedIds[0],
            _match: [{ FIELD: 'body', VALUE: 'banana', SCORE: '1.00' }]
          }
        ],
        RESULT_LENGTH: 1,
        PAGING: { NUMBER: 0, SIZE: 20, TOTAL: 1, DOC_OFFSET: 0 }
      })
    })
})

test('search with stopwords', t => {
  t.plan(1)
  global[testIndex]
    .QUERY({
      AND: [
        {
          VALUE: 'this'
        },
        {
          VALUE: 'banana'
        }
      ]
    })
    .then(res => {
      t.deepEqual(res, {
        QUERY: {
          AND: [
            { VALUE: { GTE: 'this', LTE: 'this' } },
            { VALUE: { GTE: 'banana', LTE: 'banana' } }
          ]
        },
        OPTIONS: {},
        RESULT: [
          {
            _id: autoGeneratedIds[0],
            _match: [{ FIELD: 'body', VALUE: 'banana', SCORE: '1.00' }]
          }
        ],
        RESULT_LENGTH: 1,
        PAGING: { NUMBER: 0, SIZE: 20, TOTAL: 1, DOC_OFFSET: 0 }
      })
    })
})
